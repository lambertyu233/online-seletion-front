# 前台系统-前端工程修改
request.js里面封装了axios，把axios.create的baseURL改成我们的本地接口http://localhost:8501，把api.js里的相关接口都改成我们后端的接口
## token的传递以及存储
```tex
在HTML5中，新加入了一个localStorage特性，这个特性主要是用来作为本地存储来使用的，
解决了cookie存储空间不足的问题(cookie中每条cookie的存储空间为4k)，
localStorage中一般浏览器支持的是5M大小，这个在不同的浏览器中localStorage会有所不同。
```
mock里的login.js模拟登录的响应回来的相关数据，api的lohin.js里定义了登录的地址以及请求方式，@/utils/request里面封装了axios请求。
前端调用方面，views的login的index.vue有表单提交数据后调用api的接口实现登录，此外它还调用了一个initToken方法，来自于@/pinia/modules/app，这个initToken方法通过调用setToken函数把token传进了@/utils/storage的setItem方法，最后setItem方法通过window.localStorage.setItem(name, value)把token放进了浏览器的localStorage里面进行存储，进而实现每次网页请求的登录校验。


# 后台系统-后端工程搭建
## maven聚合工程
* 模块说明：

spzx-parent： 尚品甄选项目的父工程，进行项目依赖的统一管理，打包方式为pom

spzx-common:  尚品甄选项目公共模块的管理模块，父工程为spzx-parent

common-util:    工具类模块，父工程为spzx-common

common-service：公共服务模块，父工程为spzx-common

spzx-model:  尚品甄选实体类模块

spzx-manager： 尚品甄选项目后台管理系统的后端服务



* 一个项目中所涉及到的实体类往往有三种：

1、封装请求参数的实体类：这种实体类在定义的时候往往会携带到dto【数据传输对象：Data Transfer Object】字样，会定义在dto包中

2、与数据库对应的实体类：这种实体类往往和数据表名称保证一致，会定义在domain、entity、pojo包中

3、封装响应结果的实体类：这种实体类在定义的时候往往会携带到vo【视图对象：View Object】字样，会定义在vo包中



## 后端开始编写
要用mybatisplus需要在mapper接口处继承extends BaseMapper<>
在实体类里可以用注解指定对应的表
maven里，导入了mybatisplus包后就不用再导mybatis包了，导入mybatis包的的时候会报错。

## 统一异常处理
RuntimeException返回的不是我们封装的统一result类，所有进行改造，达到统一异常处理
通过2个注解实现：
* @ControllerAdvice :Controller增强器，给Controller增加统一的操作和处理
* @ExceptionHandler :捕获Controller抛出的指定类型异常

因为是全局的，以后其他模块也会用得到，所以放到common-service模块。
* 第一步 在common-service创建统一异常处理类
* 第二步 在统一异常处理类添加@ControllerAdvice
* 在统一异常处理类，创建异常处理的方法，方法上添加注解@ExceptionHandler，指定异常类型
* 在异常的方法，返回Result数据格式

@ExceptionHandler(Exception.class)里的Exception.class会捕获所有异常，导致只要是异常都会触发方法，不符合我们的要求，所以自定义异常。
所有我们自定义一个异常GuiguException来继承RuntimeException，并且在@ExceptionHandler(GuiguException.class)里指定是我们定义的GuiguException异常，由于这是我们自定义的异常，所以需要我们手动抛出
```java
if(sysUser==null){
//throw new RuntimeException("用户名不存在！");
    throw new GuiguException(ResultCodeEnum.LOGIN_ERROR);
}
```
在Controller抛出GuiguException异常后会被@ExceptionHandler(GuiguException.class)注解捕获到，并执行异常处理方法，返回Result数据格式
```java
@ExceptionHandler(GuiguException.class)
@ResponseBody
public Result error(GuiguException e){
    e.printStackTrace();
    return Result.build(null , e.getResultCodeEnum()) ;
}
```
## 异常处理执行逻辑
通过`throw new GuiguException(ResultCodeEnum.LOGIN_ERROR);`会触发自定义异常GuiguException的`public GuiguException(ResultCodeEnum resultCodeEnum)`方法
```java
@Data
public class GuiguException extends RuntimeException{
    private Integer code;
    private String message;
    private ResultCodeEnum resultCodeEnum;
    public GuiguException(ResultCodeEnum resultCodeEnum) {
        this.code = resultCodeEnum.getCode();
        this.message = resultCodeEnum.getMessage();
        this.resultCodeEnum = resultCodeEnum;
    }
}
```
来给code，message和resultCodeEnum赋值。
同时又因为抛出了GuiguException异常，会被捕获并执行异常处理方法
```java
@ControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(GuiguException.class)
    @ResponseBody
    public Result error(GuiguException e){
        e.printStackTrace();
        return Result.build(null , e.getResultCodeEnum()) ;
    }
}
```
最后通过`e.getResultCodeEnum()`拿到异常的相关信息，并被封装为Result格式

## 跨域请求
解决跨域请求有2中方式：
- 方案一：在IndexController上添加@CrossOrigin注解
弊端：每一个controller类上都来添加这样的一个接口影响开发效率、维护性较差

- 方案二：添加一个配置类配置跨域请求
```java
// com.atguigu.spzx.manager.config
@Component
public class WebMvcConfiguration implements WebMvcConfigurer {

    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/**")      // 添加路径规则
                .allowCredentials(true)               // 是否允许在跨域的情况下传递Cookie
                .allowedOriginPatterns("*")           // 允许请求来源的域规则
            	.allowedMethods("*")
                .allowedHeaders("*") ;                // 允许所有的请求头
    }
    
}
```