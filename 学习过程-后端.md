# 后台系统-后端工程搭建
## maven聚合工程
* 模块说明：

spzx-parent： 尚品甄选项目的父工程，进行项目依赖的统一管理，打包方式为pom

spzx-common:  尚品甄选项目公共模块的管理模块，父工程为spzx-parent

common-util:    工具类模块，父工程为spzx-common

common-service：公共服务模块，父工程为spzx-common

spzx-model:  尚品甄选实体类模块

spzx-manager： 尚品甄选项目后台管理系统的后端服务



* 一个项目中所涉及到的实体类往往有三种：

1、封装请求参数的实体类：这种实体类在定义的时候往往会携带到dto【数据传输对象：Data Transfer Object】字样，会定义在dto包中

2、与数据库对应的实体类：这种实体类往往和数据表名称保证一致，会定义在domain、entity、pojo包中

3、封装响应结果的实体类：这种实体类在定义的时候往往会携带到vo【视图对象：View Object】字样，会定义在vo包中



## 后端开始编写
要用mybatisplus需要在mapper接口处继承extends BaseMapper<>
在实体类里可以用注解指定对应的表
maven里，导入了mybatisplus包后就不用再导mybatis包了，导入mybatis包的的时候会报错。

## 统一异常处理
RuntimeException返回的不是我们封装的统一result类，所有进行改造，达到统一异常处理
通过2个注解实现：
* @ControllerAdvice :Controller增强器，给Controller增加统一的操作和处理
* @ExceptionHandler :捕获Controller抛出的指定类型异常

因为是全局的，以后其他模块也会用得到，所以放到common-service模块。
* 第一步 在common-service创建统一异常处理类
* 第二步 在统一异常处理类添加@ControllerAdvice
* 在统一异常处理类，创建异常处理的方法，方法上添加注解@ExceptionHandler，指定异常类型
* 在异常的方法，返回Result数据格式

@ExceptionHandler(Exception.class)里的Exception.class会捕获所有异常，导致只要是异常都会触发方法，不符合我们的要求，所以自定义异常。
所有我们自定义一个异常GuiguException来继承RuntimeException，并且在@ExceptionHandler(GuiguException.class)里指定是我们定义的GuiguException异常，由于这是我们自定义的异常，所以需要我们手动抛出
```java
if(sysUser==null){
//throw new RuntimeException("用户名不存在！");
    throw new GuiguException(ResultCodeEnum.LOGIN_ERROR);
}
```
在Controller抛出GuiguException异常后会被@ExceptionHandler(GuiguException.class)注解捕获到，并执行异常处理方法，返回Result数据格式
```java
@ExceptionHandler(GuiguException.class)
@ResponseBody
public Result error(GuiguException e){
    e.printStackTrace();
    return Result.build(null , e.getResultCodeEnum()) ;
}
```
## 异常处理执行逻辑
通过`throw new GuiguException(ResultCodeEnum.LOGIN_ERROR);`会触发自定义异常GuiguException的`public GuiguException(ResultCodeEnum resultCodeEnum)`方法
```java
@Data
public class GuiguException extends RuntimeException{
    private Integer code;
    private String message;
    private ResultCodeEnum resultCodeEnum;
    public GuiguException(ResultCodeEnum resultCodeEnum) {
        this.code = resultCodeEnum.getCode();
        this.message = resultCodeEnum.getMessage();
        this.resultCodeEnum = resultCodeEnum;
    }
}
```
来给code，message和resultCodeEnum赋值。
同时又因为抛出了GuiguException异常，会被捕获并执行异常处理方法
```java
@ControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(GuiguException.class)
    @ResponseBody
    public Result error(GuiguException e){
        e.printStackTrace();
        return Result.build(null , e.getResultCodeEnum()) ;
    }
}
```
最后通过`e.getResultCodeEnum()`拿到异常的相关信息，并被封装为Result格式

## 跨域请求
解决跨域请求有2中方式：
- 方案一：在IndexController上添加@CrossOrigin注解
弊端：每一个controller类上都来添加这样的一个接口影响开发效率、维护性较差

- 方案二：添加一个配置类配置跨域请求
```java
// com.atguigu.spzx.manager.config
@Component
public class WebMvcConfiguration implements WebMvcConfigurer {

    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/**")      // 添加路径规则
                .allowCredentials(true)               // 是否允许在跨域的情况下传递Cookie
                .allowedOriginPatterns("*")           // 允许请求来源的域规则
            	.allowedMethods("*")
                .allowedHeaders("*") ;                // 允许所有的请求头
    }
    
}
```
## 图片验证码
### 底层实现
在Service层使用hutool生成图片验证码，并在controller层调用进行了
```java
@Service
public class ValidateCodeServiceImpl implements ValidateCodeService {

    @Autowired
    private RedisTemplate<String,String> redisTemplate;

    //生成图片验证码
    @Override
    public ValidateCodeVo generateValidateCode() {
        //1 通过工具 hutool 生成图片验证码
        //150：宽度，48：高度，4：验证码值数量，2：验证码划痕数量，干扰程度
        CircleCaptcha circleCaptcha = CaptchaUtil.createCircleCaptcha(150, 48, 4, 2);
        String codeValue = circleCaptcha.getCode();//4位验证码值
        String imageBase64 = circleCaptcha.getImageBase64();//返回图片验证码，对图片进行了base64编码
        //2 把验证码存储到redis里，设置redis的key：uuid   redis的value：验证码值
        //设置过期时间
        String key = UUID.randomUUID().toString().replaceAll("-", "");
        redisTemplate.opsForValue().set("user:validate"+key,codeValue,
                                        5, TimeUnit.MINUTES);//过期时间5，单位分钟
        //返回ValidateCodeVo对象
        ValidateCodeVo validateCodeVo = new ValidateCodeVo();
        validateCodeVo.setCodeKey(key);//redis中存储数据的key
        validateCodeVo.setCodeValue("data:image/png;base64," + imageBase64);//是要把图片设置进去，格式固定，这个数据会在页面上直接通过图片的形式显示出来
        return validateCodeVo;
    }
}
```
### 验证码校验
验证码校验应该在用户登录的接口实现，和用户名密码的代码放一块
```java
@Service
public class SysUserServiceImpl implements SysUserService {

    @Autowired
    private SysUserMapper sysUserMapper ;
    @Autowired
    private RedisTemplate<String,String> redisTemplate;

    @Override
    public LoginVo login(LoginDto loginDto) {
        //1 获取输入的验证码和存储到redis的key名称
        String captcha = loginDto.getCaptcha();
        String key = loginDto.getCodeKey();
        //2 根据获取到的redis里面的key，查询redis里面存储的验证码
        String redisCode = redisTemplate.opsForValue().get("user:validate" + key);
        //3 比较输入的验证码和redis存储的验证码是否一致
        if(StrUtil.isEmpty(captcha) || !StrUtil.equalsIgnoreCase(redisCode,captcha)){
            //4 如果不一致，提示用户校验失败
            throw new GuiguException(ResultCodeEnum.VALIDATECODE_ERROR);
        }
        //5 如果一致，删除redis里面的验证码
        redisTemplate.delete("user:validate" + key);

        QueryWrapper<SysUser> queryWrapper = new QueryWrapper<>();
        queryWrapper.eq("username",loginDto.getUserName());
        SysUser sysUser = sysUserMapper.selectOne(queryWrapper);
        if(sysUser==null){
//            throw new RuntimeException("用户名不存在！");
            throw new GuiguException(ResultCodeEnum.LOGIN_ERROR);
        }
        String input_password = DigestUtils.md5DigestAsHex(loginDto.getPassword().getBytes());
        if(!sysUser.getPassword().equals(input_password)){
//            throw new RuntimeException("密码不正确！");
            throw new GuiguException(ResultCodeEnum.LOGIN_ERROR);
        }
        String token = UUID.randomUUID().toString().replaceAll("-", "");
        redisTemplate.opsForValue().set("user:login"+token, JSON.toJSONString(sysUser),7, TimeUnit.DAYS);
        LoginVo loginVo = new LoginVo();
        loginVo.setToken(token);
        return loginVo;
    }
}
```
## 根据token获取用户信息
```java
@Override
public SysUser getUserInfo(String token) {
    String userJson = redisTemplate.opsForValue().get("user:login" + token);
    SysUser sysUser = JSON.parseObject(userJson, SysUser.class);
    return sysUser;
}
```
## 用户退出
用户退出功能前端已经实现了，后端要做的就是在退出的时候把redis里存储的用户信息删了
```java
controller层
//用户退出
@GetMapping("logout")
public Result logout(@RequestHeader String token) {
    sysUserService.logout(token);
    return Result.build(null, ResultCodeEnum.SUCCESS) ;
}

service层
@Override
public void logout(String token) {
    redisTemplate.delete("user:login" + token);
}
```
## 登录校验
后台管理系统中除了登录接口、获取验证码的接口在访问的时候不需要验证用户的登录状态，其余的接口在访问的时候都必须要求用户登录成功以后才可以进行访问。
注意：

1、请求url的判断可以通过拦截规则配置进行实现

2、更新Redis中数据的存活时间的主要目的就是为了保证用户在使用该系统的时候，Redis中会一直保证用户的登录状态，如果用户在30分钟之内没有使用该系统，那么此时登录超时。此时用户就需要重新进行登录。

3、**将从Redis中获取到的用户存储到ThreadLocal中，这样在一次请求的中就可以在controller、service、mapper中获取用户数据**
### ThreadLocal
完成该功能需要使用到ThreadLocal，ThreadLocal是jdk所提供的一个线程工具类，叫做线程变量，意思是ThreadLocal中填充的变量属于当前线程，该变量对其他线程而言是隔离的，也就是说该变量是当前线程独有的变量，使用该工具类可以实现在同一个线程进行数据的共享。
### AuthContextUtil工具类

在common-util模块中中创建一个AuthContextUtil类对ThreadLocal进行封装，代码如下所示：

```java
// com.atguigu.spzx.utils
public class AuthContextUtil {

    // 创建一个ThreadLocal对象
    private static final ThreadLocal<SysUser> threadLocal = new ThreadLocal<>() ;

    // 定义存储数据的静态方法
    public static void set(SysUser sysUser) {
        threadLocal.set(sysUser);
    }

    // 定义获取数据的方法
    public static SysUser get() {
        return threadLocal.get() ;
    }

    // 删除数据的方法
    public static void remove() {
        threadLocal.remove();
    }

}
```
### 拦截器开发

在spzx-manager服务中创建一个拦截器，代码如下：

```java
@Component
public class LoginAuthInterceptor implements HandlerInterceptor {
    @Autowired
    private RedisTemplate<String,String> redisTemplate;
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        //1 获取请求方式
        //如果请求方式是options 预检请求，直接放行
        String method = request.getMethod();
        if("OPTIONS".equals(method)){
            return true;
        }
        //2 从请求头获取token
        String token = request.getHeader("token");
        //3 如果token为空，返回错误提示
        if(StrUtil.isEmpty(token)){
            responseNoLoginInfo(response);
            return false;
        }
        //4 如果token不为空，拿着token查询redis
        String userInfoString = redisTemplate.opsForValue().get("user:login:" + token);
        //5 如果redis查询不到数据，返回错误提示
        if(StrUtil.isEmpty(token)){
            responseNoLoginInfo(response);
            return false;
        }
        //6 如果redis查询到用户信息，把用户信息放到ThreadLocal里面
        SysUser sysUser = JSON.parseObject(userInfoString, SysUser.class);
        AuthContextUtil.set(sysUser);
        //7 把redis用户信息数据更新过期时间
        redisTemplate.expire("user:login:" + token,30, TimeUnit.MINUTES);
        //8 放行
        return true;
    }

    //响应208状态码给前端
    private void responseNoLoginInfo(HttpServletResponse response) {
        Result<Object> result = Result.build(null, ResultCodeEnum.LOGIN_AUTH);
        PrintWriter writer = null;
        response.setCharacterEncoding("UTF-8");
        response.setContentType("text/html; charset=utf-8");
        try {
            writer = response.getWriter();
            writer.print(JSON.toJSONString(result));
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            if (writer != null) writer.close();
        }
    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        //ThreadLocal删除
        AuthContextUtil.remove();
    }
}
```
### 拦截器注册

想让拦截器生效，那么此时就需要将拦截器注册到Spring MVC中，具体的代码如下所示：

```java
@Component
public class WebMvcConfiguration implements WebMvcConfigurer {

    @Autowired
    private LoginAuthInterceptor loginAuthInterceptor ;

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(loginAuthInterceptor)
                .excludePathPatterns("/admin/system/index/login" , "/admin/system/index/generateValidateCode")
                .addPathPatterns("/**");
    }
}
```
### 用配置文件优化

关于不需要验证登录的请求url， 需要将其定义到对应的配置文件中，以提高代码的维护性。

具体步骤：

1、application-dev.yml添加如下自定义配置

```yaml
# 自定义配置
spzx:
  auth:
    noAuthUrls:
      - /admin/system/index/login
      - /admin/system/index/generateValidateCode
```

2、实体类定义

```java
// com.atguigu.spzx.manager.properties;

@Data
@ConfigurationProperties(prefix = "spzx.auth")      // 前缀不能使用驼峰命名
public class UserAuthProperties {
    private List<String> noAuthUrls ;
}
```

3、启动类添加注解：**@EnableConfigurationProperties(value = {UserAuthProperties.class})**

4、配置类代码修改

```java
@Component
public class WebMvcConfiguration implements WebMvcConfigurer {

    @Autowired
    private UserAuthProperties userAuthProperties ;		// 注入实体类对象

    @Autowired
    private LoginAuthInterceptor loginAuthInterceptor ;

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(loginAuthInterceptor)
                .excludePathPatterns(userAuthProperties.getNoAuthUrls())
                .addPathPatterns("/**");
    }
    
}
```
### 代码优化

后端获取用户信息的接口就无需获取token，然后根据token从Redis中进行查询。可以直接从ThreadLocal中获取用户信息，然后进行返回。

代码如下所示：

```java
// com.atguigu.spzx.manager.controller
@GetMapping(value = "/getUserInfo")
public Result<SysUser> getUserInfo() {
    return Result.build(AuthContextUtil.get()  , ResultCodeEnum.SUCCESS) ;
}
```